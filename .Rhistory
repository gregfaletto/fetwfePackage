}
for (lvls in 1:nlvls) {
effect      = ifelse(cohort==lvls, sample(2:10, 1), effect)
first_treat = ifelse(cohort==lvls, sample(1:(tmax+20), 1), first_treat)
}
first_treat = ifelse(first_treat>tmax, Inf, first_treat)
treat       = time >= first_treat
rel_time    = time - first_treat
y           = id + time + ifelse(treat, effect*rel_time, 0) + rnorm(imax*tmax)
rm(chrt, lvls, cohort, effect)
})
# Convert `dat` to `pdata` based on the specified requirements
# Specify column names for the pdata format
time_var <- "time"       # Column for the time period
unit_var <- "unit"       # Column for the unit identifier
treatment <- "treated"   # Column for the treatment dummy indicator
covs <- c()  # Columns for covariates
response <- "response"   # Column for the response variable
# Convert the dataset
pdata <- dat |>
dplyr::mutate(
# Rename id to unit and convert to character
{{ unit_var }} := as.character(id),
# Ensure treatment dummy is 0/1
{{ treatment }} := as.integer(treat),
# Rename y to response
{{ response }} := y
) |>
dplyr::select(
{{ time_var }}, {{ unit_var }}, {{ treatment }}, {{ response }}
)
head(dat)
head(pdata)
devtools::test()
devtools::test()
devtools::test()
set.seed(123456L)
# 5 time periods, 30 individuals, and 4 waves of treatment
tmax = 5; imax = 30; nlvls = 5
dat =
expand.grid(time = 1:tmax, id = 1:imax) |>
within({
# Initialize columns
cohort      = NA
effect      = NA
first_treat = NA
for (chrt in 1:imax) {
cohort = ifelse(id==chrt, sample.int(nlvls, 1), cohort)
}
for (lvls in 1:nlvls) {
effect      = ifelse(cohort==lvls, sample(2:10, 1), effect)
first_treat = ifelse(cohort==lvls, lvls + 1, first_treat)
}
first_treat = ifelse(first_treat>tmax, Inf, first_treat)
treat       = time >= first_treat
rel_time    = time - first_treat
y           = id + time + ifelse(treat, effect*rel_time, 0) + rnorm(imax*tmax)
rm(chrt, lvls, cohort, effect)
})
# Convert `dat` to `pdata` based on the specified requirements
# Specify column names for the pdata format
time_var <- "time"       # Column for the time period
unit_var <- "unit"       # Column for the unit identifier
treatment <- "treated"   # Column for the treatment dummy indicator
covs <- c()  # Columns for covariates
response <- "response"   # Column for the response variable
# Convert the dataset
pdata <- dat |>
dplyr::mutate(
# Rename id to unit and convert to character
{{ unit_var }} := as.character(id),
# Ensure treatment dummy is 0/1
{{ treatment }} := as.integer(treat),
# Rename y to response
{{ response }} := y
) |>
dplyr::select(
{{ time_var }}, {{ unit_var }}, {{ treatment }}, {{ response }}
)
result <- fetwfe(
pdata = pdata,              # The panel dataset
time_var = "time",          # The time variable
unit_var = "unit",          # The unit identifier
treatment = "treated",      # The treatment dummy indicator
covs = c(),  # Covariates
response = "response",      # The response variable
q = 0.5                    # The L_q penalty for fusion regularization
)
head(dat)
head(pdata)
dat$first_treat
unique(dat$first_treat)
devtools::test()
devtools::test()
remove.packages("fetwfe")
# install.packages("remotes")  # if needed
remotes::install_github("gregfaletto/fetwfePackage")
library(fetwfe)
?fetwfe
set.seed(23451)
library(bacondecomp)
data(divorce)
# sig_eps_sq and sig_eps_c_sq, calculated in a separate run of `fetwfe(),
# are provided to speed up the computation of the example
res <- fetwfe(
pdata = divorce[divorce$sex == 2, ],
time_var = "year",
unit_var = "st",
treatment = "changed",
covs = c("murderrate", "lnpersinc", "afdcrolls"),
response = "suiciderate_elast_jag",
sig_eps_sq = 0.1025361,
sig_eps_c_sq = 4.227651e-35,
verbose = TRUE)
# Average treatment effect on the treated units (in percentage point
# units)
100 * res$att_hat
# Conservative 95% confidence interval for ATT (in percentage point units)
low_att <- 100 * (res$att_hat - qnorm(1 - 0.05 / 2) * res$att_se)
high_att <- 100 * (res$att_hat + qnorm(1 - 0.05 / 2) * res$att_se)
c(low_att, high_att)
# Cohort average treatment effects and confidence intervals (in percentage
# point units)
catt_df_pct <- res$catt_df
catt_df_pct[["Estimated TE"]] <- 100 * catt_df_pct[["Estimated TE"]]
catt_df_pct[["SE"]] <- 100 * catt_df_pct[["SE"]]
catt_df_pct[["ConfIntLow"]] <- 100 * catt_df_pct[["ConfIntLow"]]
catt_df_pct[["ConfIntHigh"]] <- 100 * catt_df_pct[["ConfIntHigh"]]
catt_df_pct
devtools::test()
remove.packages("fetwfe")
# install.packages("remotes")  # if needed
remotes::install_github("gregfaletto/fetwfePackage")
set.seed(123456L)
# 60 time periods, 30 individuals, and 5 waves of treatment
tmax = 60; imax = 30; nlvls = 5
dat =
expand.grid(time = 1:tmax, id = 1:imax) |>
within({
cohort      = NA
effect      = NA
first_treat = NA
for (chrt in 1:imax) {
cohort = ifelse(id==chrt, sample.int(nlvls, 1), cohort)
}
for (lvls in 1:nlvls) {
effect      = ifelse(cohort==lvls, sample(2:10, 1), effect)
first_treat = ifelse(cohort==lvls, sample(1:(tmax+20), 1), first_treat)
}
first_treat = ifelse(first_treat>tmax, Inf, first_treat)
treat       = time>=first_treat
rel_time    = time - first_treat
y           = id + time + ifelse(treat, effect*rel_time, 0) + rnorm(imax*tmax)
rm(chrt, lvls, cohort, effect)
})
head(dat)
# Specify column names for the pdata format
time_var <- "time"       # Column for the time period
unit_var <- "unit"       # Column for the unit identifier
treatment <- "treated"   # Column for the treatment dummy indicator
covs <- c()  # Columns for covariates
response <- "response"   # Column for the response variable
# Convert the dataset
pdata <- dat |>
dplyr::mutate(
# Rename id to unit and convert to character
{{ unit_var }} := as.character(id),
# Ensure treatment dummy is 0/1
{{ treatment }} := as.integer(treat),
# Rename y to response
{{ response }} := y
) |>
dplyr::select(
{{ time_var }}, {{ unit_var }}, {{ treatment }}, {{ response }}
)
# Preview the resulting pdata dataframe
head(pdata)
library(fetwfe)
result <- fetwfe(
pdata = pdata,              # The panel dataset
time_var = "time",          # The time variable
unit_var = "unit",          # The unit identifier
treatment = "treated",      # The treatment dummy indicator
covs = c(),  # Covariates
response = "response",      # The response variable
q = 0.5,                    # The L_q penalty for fusion regularization
verbose = TRUE              # Print details of the progress
)
result$att_hat
remove.packages("fetwfe")
# install.packages("remotes")  # if needed
remotes::install_github("gregfaletto/fetwfePackage")
library(fetwfe)
?fetwfe
set.seed(23451)
library(bacondecomp)
data(divorce)
# sig_eps_sq and sig_eps_c_sq, calculated in a separate run of `fetwfe(),
# are provided to speed up the computation of the example
res <- fetwfe(
pdata = divorce[divorce$sex == 2, ],
time_var = "year",
unit_var = "st",
treatment = "changed",
covs = c("murderrate", "lnpersinc", "afdcrolls"),
response = "suiciderate_elast_jag",
sig_eps_sq = 0.1025361,
sig_eps_c_sq = 4.227651e-35,
verbose = TRUE)
# Average treatment effect on the treated units (in percentage point
# units)
100 * res$att_hat
# Conservative 95% confidence interval for ATT (in percentage point units)
low_att <- 100 * (res$att_hat - qnorm(1 - 0.05 / 2) * res$att_se)
high_att <- 100 * (res$att_hat + qnorm(1 - 0.05 / 2) * res$att_se)
c(low_att, high_att)
# Cohort average treatment effects and confidence intervals (in percentage
# point units)
catt_df_pct <- res$catt_df
catt_df_pct[["Estimated TE"]] <- 100 * catt_df_pct[["Estimated TE"]]
catt_df_pct[["SE"]] <- 100 * catt_df_pct[["SE"]]
catt_df_pct[["ConfIntLow"]] <- 100 * catt_df_pct[["ConfIntLow"]]
catt_df_pct[["ConfIntHigh"]] <- 100 * catt_df_pct[["ConfIntHigh"]]
catt_df_pct
devtools::test()
devtools::test()
remove.packages("fetwfe")
# install.packages("remotes")  # if needed
remotes::install_github("gregfaletto/fetwfePackage")
library(fetwfe)
?fetwfe
devtools::document()
remove.packages("fetwfe")
# install.packages("remotes")  # if needed
remotes::install_github("gregfaletto/fetwfePackage")
library(fetwfe)
?fetwfe
set.seed(23451)
library(bacondecomp)
data(divorce)
# sig_eps_sq and sig_eps_c_sq, calculated in a separate run of `fetwfe(),
# are provided to speed up the computation of the example
res <- fetwfe(
pdata = divorce[divorce$sex == 2, ],
time_var = "year",
unit_var = "st",
treatment = "changed",
covs = c("murderrate", "lnpersinc", "afdcrolls"),
response = "suiciderate_elast_jag",
sig_eps_sq = 0.1025361,
sig_eps_c_sq = 4.227651e-35,
verbose = TRUE)
# Average treatment effect on the treated units (in percentage point
# units)
100 * res$att_hat
# Conservative 95% confidence interval for ATT (in percentage point units)
low_att <- 100 * (res$att_hat - qnorm(1 - 0.05 / 2) * res$att_se)
high_att <- 100 * (res$att_hat + qnorm(1 - 0.05 / 2) * res$att_se)
c(low_att, high_att)
# Cohort average treatment effects and confidence intervals (in percentage
# point units)
catt_df_pct <- res$catt_df
catt_df_pct[["Estimated TE"]] <- 100 * catt_df_pct[["Estimated TE"]]
catt_df_pct[["SE"]] <- 100 * catt_df_pct[["SE"]]
catt_df_pct[["ConfIntLow"]] <- 100 * catt_df_pct[["ConfIntLow"]]
catt_df_pct[["ConfIntHigh"]] <- 100 * catt_df_pct[["ConfIntHigh"]]
catt_df_pct
devtools::test()
devtools::build()
devtools::test()
devtools::document()
devtools::build()
devtools:document()
devtools::document()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::build()
devtools::test()
devtools::build()
devtools::build()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::test()
devtools::test()
devtools::build()
devtools::test()
?fetwfe
set.seed(23451)
library(bacondecomp)
data(divorce)
# sig_eps_sq and sig_eps_c_sq, calculated in a separate run of `fetwfe(),
# are provided to speed up the computation of the example
res <- fetwfe(
pdata = divorce[divorce$sex == 2, ],
time_var = "year",
unit_var = "st",
treatment = "changed",
covs = c("murderrate", "lnpersinc", "afdcrolls"),
response = "suiciderate_elast_jag",
sig_eps_sq = 0.1025361,
sig_eps_c_sq = 4.227651e-35,
verbose = TRUE)
# Average treatment effect on the treated units (in percentage point
# units)
100 * res$att_hat
# Conservative 95% confidence interval for ATT (in percentage point units)
low_att <- 100 * (res$att_hat - qnorm(1 - 0.05 / 2) * res$att_se)
high_att <- 100 * (res$att_hat + qnorm(1 - 0.05 / 2) * res$att_se)
c(low_att, high_att)
# Cohort average treatment effects and confidence intervals (in percentage
# point units)
catt_df_pct <- res$catt_df
catt_df_pct[["Estimated TE"]] <- 100 * catt_df_pct[["Estimated TE"]]
catt_df_pct[["SE"]] <- 100 * catt_df_pct[["SE"]]
catt_df_pct[["ConfIntLow"]] <- 100 * catt_df_pct[["ConfIntLow"]]
catt_df_pct[["ConfIntHigh"]] <- 100 * catt_df_pct[["ConfIntHigh"]]
catt_df_pct
genCoefs <- function(R, T, density, eff_size, num_treats, p, d){
theta <- rep(0, p)
# Make sure at least one feature is selected
pass_condition <- FALSE
while(!pass_condition){
theta_inds <- which(as.logical(rbinom(n=p, size=1, prob=density)))
pass_condition <- length(theta_inds > 0)
}
num_coefs <- length(theta_inds)
signs <- rfunc(num_coefs, prob=0.6)
theta[theta_inds] <- eff_size*signs
# Now we have coefficients that are sparse in the appropriate feature space.
# The last step is to transform them to the original feature space. Since
# theta = D %*% beta, beta = solve(D) %*% theta.
beta <- rep(as.numeric(NA), p)
beta[1:R] <- genBackwardsInvFusionTransformMat(R) %*% theta[1:R]
stopifnot(all(is.na(beta[(R + 1):(R + T - 1)])))
beta[(R + 1):(R + T - 1)] <- genBackwardsInvFusionTransformMat(T - 1) %*%
theta[(R + 1):(R + T - 1)]
# Coefficients corresponding to X don't need to be transformed
stopifnot(all(is.na(beta[(R + T - 1 + 1):(R + T - 1 + d)])))
beta[(R + T - 1 + 1):(R + T - 1 + d)] <- theta[(R + T - 1 + 1):
(R + T - 1 + d)]
# Cohort-X interactions (one cohort at a time, with all interactions for
# X. So R blocks of size d.)
for(j in 1:d){
first_ind_j <- R + T - 1 + d + j
last_ind_j <- R + T - 1 + d + (R - 1)*d + j
inds_j <- seq(first_ind_j, last_ind_j, by=d)
stopifnot(length(inds_j) == R)
stopifnot(all(is.na(beta[inds_j])))
beta[inds_j] <- genBackwardsInvFusionTransformMat(R) %*% theta[inds_j]
}
stopifnot(all(!is.na(beta[1:(R + T - 1 + d + R*d)])))
stopifnot(all(is.na(beta[(R + T - 1 + d + R*d + 1):p])))
# Time-X interactions
for(j in 1:d){
first_ind_j <- R + T - 1 + d + R*d + j
last_ind_j <- R + T - 1 + d + R*d + (T - 2)*d + j
inds_j <- seq(first_ind_j, last_ind_j, by=d)
stopifnot(length(inds_j) == T - 1)
stopifnot(all(is.na(beta[inds_j])))
beta[inds_j] <- genBackwardsInvFusionTransformMat(T - 1) %*% theta[inds_j]
}
stopifnot(all(!is.na(beta[1:(R + T - 1 + d + R*d + (T - 1)*d)])))
stopifnot(all(is.na(beta[(R + T - 1 + d + R*d + (T - 1)*d + 1):p])))
# Base treatment effects: need to identify indices of first treatment
# effect for each cohort
first_inds <- getFirstInds(num_treats, R, T)
treat_inds <- (R + T - 1 + d + R*d + (T - 1)*d + 1):
(R + T - 1 + d + R*d + (T - 1)*d + num_treats)
stopifnot(all(is.na(beta[treat_inds])))
beta[treat_inds] <- genInvTwoWayFusionTransformMat(num_treats,
first_inds, R) %*% theta[treat_inds]
stopifnot(all(!is.na(beta[1:(R + T - 1 + d + R*d + (T - 1)*d +
num_treats)])))
stopifnot(all(is.na(beta[(R + T - 1 + d + R*d + (T - 1)*d + num_treats +
1):p])))
# Treatment effect-X interactions
for(j in 1:d){
first_ind_j <- R + T - 1 + d + R*d + (T - 1)*d + num_treats + j
last_ind_j <- R + T - 1 + d + R*d + (T - 1)*d + num_treats +
(num_treats - 1)*d + j
inds_j <- seq(first_ind_j, last_ind_j, by=d)
stopifnot(length(inds_j) == num_treats)
stopifnot(all(is.na(beta[inds_j])))
beta[inds_j] <- genInvTwoWayFusionTransformMat(num_treats,
first_inds, R) %*% theta[inds_j]
}
stopifnot(all(!is.na(beta)))
return(list(beta=beta, theta=theta))
}
genCoefs <- function(R, T, density, eff_size, d){
num_treats <- T * R - (R * (R + 1)) / 2
if (d > 0) {
p <- R + (T - 1) + d + d * R + d * (T - 1) + num_treats + num_treats * d
} else {
p <- R + (T - 1) + num_treats
}
theta <- rep(0, p)
# Make sure at least one feature is selected
pass_condition <- FALSE
while(!pass_condition){
theta_inds <- which(as.logical(rbinom(n=p, size=1, prob=density)))
pass_condition <- length(theta_inds > 0)
}
num_coefs <- length(theta_inds)
signs <- rfunc(num_coefs, prob=0.6)
theta[theta_inds] <- eff_size*signs
# Now we have coefficients that are sparse in the appropriate feature space.
# The last step is to transform them to the original feature space. Since
# theta = D %*% beta, beta = solve(D) %*% theta.
beta <- rep(as.numeric(NA), p)
beta[1:R] <- genBackwardsInvFusionTransformMat(R) %*% theta[1:R]
stopifnot(all(is.na(beta[(R + 1):(R + T - 1)])))
beta[(R + 1):(R + T - 1)] <- genBackwardsInvFusionTransformMat(T - 1) %*%
theta[(R + 1):(R + T - 1)]
# Coefficients corresponding to X don't need to be transformed
stopifnot(all(is.na(beta[(R + T - 1 + 1):(R + T - 1 + d)])))
beta[(R + T - 1 + 1):(R + T - 1 + d)] <- theta[(R + T - 1 + 1):
(R + T - 1 + d)]
# Cohort-X interactions (one cohort at a time, with all interactions for
# X. So R blocks of size d.)
for(j in 1:d){
first_ind_j <- R + T - 1 + d + j
last_ind_j <- R + T - 1 + d + (R - 1)*d + j
inds_j <- seq(first_ind_j, last_ind_j, by=d)
stopifnot(length(inds_j) == R)
stopifnot(all(is.na(beta[inds_j])))
beta[inds_j] <- genBackwardsInvFusionTransformMat(R) %*% theta[inds_j]
}
stopifnot(all(!is.na(beta[1:(R + T - 1 + d + R*d)])))
stopifnot(all(is.na(beta[(R + T - 1 + d + R*d + 1):p])))
# Time-X interactions
for(j in 1:d){
first_ind_j <- R + T - 1 + d + R*d + j
last_ind_j <- R + T - 1 + d + R*d + (T - 2)*d + j
inds_j <- seq(first_ind_j, last_ind_j, by=d)
stopifnot(length(inds_j) == T - 1)
stopifnot(all(is.na(beta[inds_j])))
beta[inds_j] <- genBackwardsInvFusionTransformMat(T - 1) %*% theta[inds_j]
}
stopifnot(all(!is.na(beta[1:(R + T - 1 + d + R*d + (T - 1)*d)])))
stopifnot(all(is.na(beta[(R + T - 1 + d + R*d + (T - 1)*d + 1):p])))
# Base treatment effects: need to identify indices of first treatment
# effect for each cohort
first_inds <- getFirstInds(num_treats, R, T)
treat_inds <- (R + T - 1 + d + R*d + (T - 1)*d + 1):
(R + T - 1 + d + R*d + (T - 1)*d + num_treats)
stopifnot(all(is.na(beta[treat_inds])))
beta[treat_inds] <- genInvTwoWayFusionTransformMat(num_treats,
first_inds, R) %*% theta[treat_inds]
stopifnot(all(!is.na(beta[1:(R + T - 1 + d + R*d + (T - 1)*d +
num_treats)])))
stopifnot(all(is.na(beta[(R + T - 1 + d + R*d + (T - 1)*d + num_treats +
1):p])))
# Treatment effect-X interactions
for(j in 1:d){
first_ind_j <- R + T - 1 + d + R*d + (T - 1)*d + num_treats + j
last_ind_j <- R + T - 1 + d + R*d + (T - 1)*d + num_treats +
(num_treats - 1)*d + j
inds_j <- seq(first_ind_j, last_ind_j, by=d)
stopifnot(length(inds_j) == num_treats)
stopifnot(all(is.na(beta[inds_j])))
beta[inds_j] <- genInvTwoWayFusionTransformMat(num_treats,
first_inds, R) %*% theta[inds_j]
}
stopifnot(all(!is.na(beta)))
return(list(beta=beta, theta=theta))
}
genCoefs(R=5, T=30, density=0.1, eff_size=2, d=12)
devtools::build()
devtools::test()
genCoefs(R=5, T=30, density=0.1, eff_size=2, d=12)
devtools::test()
devtools::test()
devtools::build()
devtools::test()
devtools::build()
devtools::test()
devtools::test()
devtools::build()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::build()
devtools::document()
devtools::test()
